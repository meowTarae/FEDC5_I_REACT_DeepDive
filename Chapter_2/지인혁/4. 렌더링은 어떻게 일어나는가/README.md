# 렌더링은 어떻게 일어나는가?

렌더링이란 HTML과 CSS 리소스를 기반으로 웹 페이지에 필요한 UI를 그리는 과정을 의미 렌더링이 어떻게 이뤄지느냐에 따라 성능에도 큰 영향을 미친다.

리액트의 렌더링은 브라우저가 렌더링에 필요한 DOM 트리를 만드는 과정을 의미한다.

리액트의 렌더링은 시간과 리소스를 소비해 수행되는 과정으로 이 비용은 모두 웹 애플리케이션을 방문하는 사용자에게 청구되며, 시간이 길어지고 복잡해질수록 유저의 사용자 경험을 저해한다.

### 리액트의 렌더링이란?

리액트에서의 렌더링이란 리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고 있는 props와 state의 값을 기반으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 일련의 과정을 의미.

### 리액트의 렌더링이 일어나는 이유

1. 최초 렌더링

2. 리렌더링 : 최초렌더링이 발생한 이후로 발생하는 모든 렌더링

> 리렌더링이 발생하는 경우

1. 클래스형 컴포넌트의 setState가 실행되는 경우

2. 클래스형 컴포넌트의 forceUpdate가 실행되는 경우

3. 함수형 컴포넌트의 useState()의 두 번째 배열 요소인 setter가 실행되는 경우

4. 함수형 컴포넌트의 useReducer()의 두 번째 배열 요소인 dispatch가 실행되는 경우

5. 컴포넌트의 key props가 변경되는 경우

6. props가 변경되는 경우

7. 부모 컴포넌트가 렌더링될 경우

리액트에서 key는 리렌더링이 발생하는 동안 형제 요소들 사이엥서 동일한 요소를 식별하는 값이다.

리렌더링이 발생하면 current 트리와 workInProgress 트리 사이엥서 어떠한 컴포넌트가 변경이 있었는지 구별해야 하는데, 이 두 트리 사이에서 같은 컴포넌트인지를 구별하는 값이 바로 key다.

key가 존재한다면 두 트리 사이에서 통일한 key를 가지고 있는 컴포넌트는 이를 기준으로 구별할 수 있지만, 이 key가 없다면 단순히 파이버 내부의 sibling 인덱스만을 기준으로 판단하게 된다.

key의 변화는 리렌더링을 야기하며 이러한 특징을 이용하면 key를 활용해 갈제로 리렌더링을 일으키는 것이 가능하다.

### 리액트의 렌더링 프로세스

렌더링 프로세스가 시작되면 리액트는 컴포넌트의 루트에서부터 차근차근 아래쪽으로 내려가면서 업데이트가 필요하다고 지정돼 잇는 모든 컴포넌트를 찾는다.

업데이트가 필요하다고 지정돼 있는 컴포넌트를 발견하면 함수형 컴포넌트의 경우 그 자체를 호출한 뒤에, 그 결과물을 저장한다.

렌더링 결과물은 JSX 문법으로 구성돼 있고 자바스크립트로 컴파일되면서 REact.createElement()를 호출하는 구문으로 변환된다.

각 컴포넌트의 렌더링 결과물을 수집한 다음, 리액트의 새로운 트리인 가상 DOM과 비교해 실제 DOM에 반영하기 위한 모든 변경하기 위한 모든 변경 사항을 차례차례 수집한다.

이렇게 계산하는 과정을 바로 리액트의 재조정이라고 한다. 재조정 과정이 모두 끝나면 모든 변경 사항을 하나의 동기 시퀀스로 DOM에 적용해 변경된 결과물이 보이게 된다.

### 렌더와 커밋

렌더 단계는 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업이다. 컴포넌트를 실행해 이 결과와 이전 가상 DOM을 비교하는 과정을 거쳐 변경이 필요한 컴포넌트를 체크하는 단계다. 비교하는 것은 type, props, key며 이 세 가지 중 하나라도 변경된 것이 있으면 변경이 필요한 컴포넌트로 체크해 둔다.

커밋 단계는 렌더 단게의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정을 말한다. 이 단계가 끝나야 비로소 브라우저의 렌더링이 발생한다.

리액트가 먼저 DOM을 커밋 단계에서 업데이트한다면 만들어진 모든 DOM 노드 및 인스턴스를 가리키도록 리액트 내부의 참조를 업데이트한다.

리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것은 아니다. 변경 사항을 계산했는데 아무런 변경 사항이 감지되지 않는다면 이 커밋 단계를 생략될 수 있다.

두 가지 과정으로 이뤄진 리액트의 렌더링은 항상 동기식으로 작동했다. 비동기 방식으로 이뤄질 경우 사용자는 하나의 상태에 대해 여러 가지 다른 UI를 보게 될 것이다.

A라는 상태가 변경되면 B와 C가 각각 B1, C1이 되어야 하는데, A가 변경됐음에도 하나의 컴포넌트가 뒤늦게 변경되어 B, C1 상태로 남아있다면 사용자에게 혼란을 줄 수 있다.

하지만 비동기 렌더링 시나리오는 몇 가지 상황에서 유효할 수 있다. B의 컴포넌트 렌더링 작업이 무거워 상대적으로 빠르게 렌더링할 수 있는 C라도 변경해서 보여줄 수 있다면 의도된 우선순위로 컴포넌트를 렌더링해 최적화할 수 있는 비동기 렌더링, 동시성 렌더링이 리액트 18에서 도입됐다.

렌더 단계가 비동기로 작동해 특정 렌더링의 우선순위를 낮추거나, 필요핟마ㅕㄴ 중단하거나 재시작하거나, 경우에 따라서는 포기할 수도 있다.
