# 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션

리액트에서 제공하는 API 중 useMemo, useCallback 훅과 고차 컴포넌트인 memo는 리액트에서 발생하는 렌더링을 최소한으로 줄이기 위해서 제공된다.

메모이제이션 기법은 언제 사용하는 것이 좋을까? 메모이제이션 최적화는 리액트 커뮤니티에서 오랜 논쟁 주제 중 하나다.

### 주장1 : 섣부른 최적화는 독이다. 꼭 필요한 곳에만 메모이제이션을 추가하자

꼭 필요한 곳을 신중히 골라서 메모이제이션해야 한다는 입장이다. 메모이제이션도 어디까지나 비용이 드는 작업이므로 최적화에 대한 비용을 지불 할 때는 항상 신중해야 한다고 주장한다.

가벼운 작업 자체는 메모이제이션해서 자바스르킵트 메모리 어딘가에 두었다가 그것을 다시 꺼내오는 것보다는 매번 이 작업을 수행해 결과를 반환하는 것이 더 빠를 수도 있다.

메모이제이션에도 비용이 든다. 값을 비교하고 렌더링 또는 재계산이 필요한지 확인하는 작업, 이전에 결과물을 저장해 두었다가 다시 꺼내와야 한다는 두 가지 비용이 있다. 과연 이 비용이 리렌더링 비용보다 저렴하독 할 수 있을까? 그것은 상황에 따라 다를 것이다.

만약 이렇나 비교와 렌더링이 문제가 됐다면 리액트에서는 진작에 모든 컴포넌트를 PureComponent로 만들었거나 memo로 감싸두는 작업을 했을 것이다. 그렇지 않고 이를 개발자에게 선택권으로 쥐어주었다는 것은 메모이제이션이 모든 문제를 해결할 수 있는 은탄환이 아니라는 사실을 방증한다.

렌더링도 비용이지만 메모리에 저장하는 것도 마찬가지로 비용이다. 메모이제이션으로 인한 성능 개선이 렌더링보다 낫지 않다면 결국 안하느니만 못하느 상황을 마주하게 되는 것이다.

미리 개발자가 렌더링이 많이 될것 같은 부분을 예측해 메모이제이션하는 섣부른 최적화는 옳지 못한 행동이며 개발자 도구나 useEffect를 사용해 실제로 어떻게 렌더링이 일어나고 있는지 확인하고 필요한 곳에서만 최적화하는 것이 옳다.

### 주장2 : 렌더링 과정의 비용은 비싸다. 모조리 메모이제이션해 버리자

섣부른 최적화인지 여부와는 관계없이, 만약 해당 컴포넌트가 렌더링이 자주 일어나며 그 렌더링 사잉에 비싼 연산이 포함돼 있고, 심지어 그 컴포넌트가 자식 컴포넌트 또한 많이 가지고 있다면 memo나 다른 메모이제이션 방법을 사용하는 것이 이점이 있을 때가 분명히 있다.

1. 사용에 따라 잘 살펴보고 일부에만 적용하는 방법

2. 그냥 다 적용하는 방법

일단 memo로 감싼 뒤 생각해보는건 어떨까? 렌더링 비용이 저렴하거나 사실 별로 렌더링이 안 되는 컴포넌트에 memo를 썻을 때 역으로 지불해야 하는 비용을 생각해 보자.

잘못된 memo로 지불해야 하는 비용은 바로 props에 대한 얕은 비교가 발생하면서 지불해야 하는 비용이다. 메모이제이션을 위해서는 CPU와 메모리를 사용해 이전 렌더링 결과물을 저장해 둬야 하고, 리렌더링할 필요가 없다면 다음 렌더링과 구별하기 위해 저장해 둬야 한다.

기본적인 리액트 재조정 알기르즘이기 대문에 이전 결과물은 어떻게 저장해두고 있다. 따라서 우리가 memo로 지불해야 하는 비용은 props에 대한 얕은 비교뿐인 것이다. 물론 이 비용 또한 무시할 수 없다. props가 크고 복잡해진다면 이 비용 또한 커질 수 있다.

memo를 하지 않았을 때 발생할 수 있는 문제

1. 렌더링을 함으로써 발생하는 비용

2. 컴포넌트 내부에 복잡한 로직의 재실행

3. 위 두 가지 모두가 모든 자식 컴포넌트에서 반복

4. 리액트가 구 트리와 신규 트리를 비교

memo를 하지 않았을 때 치러야 할 잠재적인 위험 비용이 더 크다는 사실이다.

useMemo와 useCallback을 사용해 의존성 배열을 비교하고, 필요에 따라 값을 재계산하는 과정과 이러한 처리 없이 값과 함수를 매번 재생성하는 비용 중에서 무엇이 더 저렴한지 매번 계산해야 한다.

리렌더링이 발생할 때 메모이제이션과 같은 별도 조치가 ㅇ벗다면 모든 객체는 재생성되고, 결과적으로 참조는 달라지게 된다. 이 값이 useEffect와 같은 의존성 배열에 쓰이면 어떻게 될까 변경된 참조로 인해 다른 쪽에도 영향을 미친다.

정리하자면 메모이제이션을 하지 않는 것보다 메모이제이션을 했을 때 더 많은 이점을 누릴 수 있다. 이것이 비록 섣부른 초기화라 할지라도 했을 때 누를 수 있는 이점이다. 그리고 실수로 빠트렷을 때 치러야 할 위험 비용이 더 크기 때문에 최적화에 대한 확신이 없다면 가능한 모든 곳에 메모이제이션을 활용한 최적화를 하는 것이 좋다.

> useCallback, useMemo의 경우 대부분 다른 컴포넌트의 props로 넘어가는 경우가 많다. 이 props로 넘어갔을 때 참조 투명성을 유지하기 위해서는 메모이제이션을 사용하는 것이 좋다.
