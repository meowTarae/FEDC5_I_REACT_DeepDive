# 클래스형 컴포넌트와 함수형 컴포넌트

함수형 컴포넌트는 최근에 생겼다고 오해하지만 사실 함수형 컴포넌트는 리액트 0.14버전부터 만들어진 역사 깊은 컴포넌트 선언 방식이다.

무상태 함수형 컴포넌트라고 해서 별도의 상태 없이 단순히 어떠한 요솔르 정적으로 렌더링하는 것이 목적였다.

```JSX
const App = (props) => {
    const text = getText(props.title);

    return <div>{text}</div>
}
```

당시 함수형 컴포넌트는 클래스형 컴포넌트에서 별다른 생명주기 메서드나 상태가 필요 없이 render만 하는 경우에만 제한적으로 사용됐다.

함수형 컴포넌트에 훅이 등장한 이후 함수형 컴포넌트에서 상태나 생명주기 메서드 비슷한 작업을 흉내 낼 수 있게 되자 상대적으로 보일러플레이트가 복잡한 클래스형 컴포넌트보다 함수형 컴포넌트를 더 많이 쓰기 시작했다.

<hr>

### 클래스형 컴포넌트

리액트 16.8 미만으로 작성된 코드에는 클래스형 컴포넌트가 대다수다.

```JSX
import React from  'react'

class SampleComponent extends React.Component {
    render() {
        return <h2>Sample Component</h2>
    }
}
```

기본적으로 클래스형 컴포넌트를 만들려면 클래스를 선언하고 extends로 만들고 싶은 컴포넌트를 extends해야 한다.

extends 구문에 넣을 수 있는 클래스는 React.Component, React.pureComponent가 있다.

-   constructor()

컴포넌트 내부에 이 생성자 함수가 있다면 컴포넌트가 초기화되는 시점에 호출되고 컴포넌트의 state를 초기화할 수 있다. 그리고 super()는 컴포넌트를 만들면서 상속받은 상위 컴포넌트를 먼저 호출해 필요한 상위 컴포넌트에 접근할 수 있게 도와준다.

-   props

함수에 인수를 넣는 것과 비슷하게, 컴포넌트에 특정 속성을 전달하는 용도로 쓰인다.

-   state

클래스형 컴포넌트 내부에서 관리하는 값을 의미하며 **반드시 객체**여만 한다. 이 값에 변화가 있을 때마다 리렌더링이 발생한다.

-   메서드

렌더링 함수 내부에서 사용되는 함수이며, 보통 DOM에서 발생하는 이벤트와 함께 사용된다.

메서드를 반드는 방식은 3가지로 나뉜다.

1. constructor에서 this를 바인드하는 방법

일반적인 함수로 메서드를 만들면 this가 undefined로 나오는 현상을 겪는데 일반 함수로 호출하게 되면 this에 전역 객체가 바인딩되기 때문이다.

생성된 함수에 bind를 활용해 강제로 this를 바인딩 해야한다.

2. 화살표 함수를 쓰는 방법

this가 상위 스코프로 결정되는 화살표 함수를 사용한다면 굳이 바인딩하지 않더라도 사용할 수 있다.

3. 렌더링 함수 내부에서 함수를 새롭게 만들어 전달하는 방법

```JSX
<button onClick={() => this.handleClick()}>증가</button>
```

이 방법을 사용하게 되면 매번 렌더링이 일어날 때마다 새로운 함수를 생성해서 할당하게 되므로 최적화를 수행하기 매우 힘들다. 이 방법은 지양하는 것이 좋다.

<hr>

### 클래스형 컴포넌트의 생명주기 메서드

클래스형 컴포넌트의 많은 코드가 생명주기 메서드에 의존하고 있다.

생명주기 메서드가 실행되는 시점은 크게 3가지로 나눌 수 있다.

1. 마운트 : 컴포넌트가 마운팅(생성)되는 시점

2. 업데이트 : 이미 생성된 컴포넌트의 내용이 변경(업데이트)되는 시점

3. 언마운트 : 컴포넌트가 더 이상 존재하지 않는 시점

#### render()

render() 또한 생명주기 메서드 중 하나로, 클래스형 컴포넌트의 유일한 필수 값으로 항상 쓰인다.

이 함수는 컴포넌트가 UI를 렌더링하기 위해 쓰이며 이 렌더링은 마운트와 업데이트 과정에서 일어난다.

render() 함수는 항상 순수해야 하며 부수 효과가 없어야 한다는 것이다. 같은 입력값이 들어가면 항상 같은 결과물을 반환해야한다.

render() 내부에서 state를 직접 업데이트하는 setState를 호출해서는 안된다. state를 변경하는 일은 클래스형 컴포넌트의 메서드나 다른 생명주기 메서드 내부에서 발생해야한다.

그러므로 이 함수는 항상 최대한 간결하고 깔끔하게 작성하는 것이 좋다. 그것이 이 함수 내의 부소효과를 만들지 않고, 또 컴포넌트, 애플리케이션을 유지보수 가능하게끔 도와준다.

#### componentDidMount()

클래스형 컴포넌트가 마운트되고 준비가 됐다면 그 다음으로 호출되는 생명주기 메서드가 바로 componentDidMount()ek.

이 함수는 컴포넌트가 마운트되고 준비되는 즉시 실행되며 render()와는 다르게 함수 내부에서 setState()로 state 값을 변경하는 것이 가능하다.

setState를 호출했다면 state가 변경되고 즉시 다리 한번 렌더링을 시도하는데, 이 작업은 브라우저가 실제로 UI를 업데이트하기 전에 실행되어 사용자가 변경되는 것을 눈치챌 수 없게 만든다.

componentDidMount는 성능 문제를 일으킬 수 있음에 주의하자 일반적으로 state를 다루는 것인 생성자에서 하는 것이 좋다.

componentDidMount에서는 API 호출 후 업데이트, DOM에 의존적인 작업(이벤트 리스너 추가 등) 등을 하기 위해서다.

#### componentDidUpdate()

componentDidUpdate()는 컴포넌트 업데이트가 일어난 이후 바로 실행된다.

state나 props의 변화에 따라 DOM을 업데이트하는 등에 쓰인다. 여기서도 setState를 사용할 수 있지만 적절한 조건문으로 감싸지 않는다면 setState가 계속해서 호출되는 일이 발생할 수 있다.

#### componentWillUnmount()

컴포넌트가 언마운트되거나 더 이상 사용되지 않기 직전에 호출된다. 메모리 누수나 불필요한 작동을 막기 위한 클린업 함수를 호출하기 위한 최적의 위치다.

이 메서드 내에서는 setState를 호출할 수 없다.

#### shouldComponentUpdate()

state나 props의 변경으로 리액트 컴포넌트가 다시 리렌더링되는 것을 막고 싶다면 이 생명주기 메서드를 사용하면 된다.

기본적으로 setState가 호출되면 컴포넌트는 리렌더링을 이르킨다. 그러나 이 생명주기 메섣르르 활용하면 컴포넌트에 영향을 받지 않는 변화에 대해 정의할 수 있다.

리렌더링되는 것은 굉장히 자연스러운 일이므로 이 메서드를 사용하는 것은 특정한 성능 최적화 상황에만 고려해야한다.

#### Component vs PureComponent

이 둘의 차이점이 바로 생명주기를 다루는데 있다.

Component는 state가 업데이트되는 대로 렌더링이 일어나지만 PureComponent는 state 값에 대해 얕은 비교를 수행하여 결과가 다를 때만 렌더링을 수행한다.

PureComponent는 먼저 얕은 비교만 수행하기 때문에 state가 객체와 같이 복잡한 구조의 데이터 변경은 감지하지 못하기 때문에 재대로 작동하지 않는다.

만약 컴포넌트가 얕은 비교를 했을 때 일치하지 않는 일이 더 잦다면 당연히 이러한 비교는 무의미하다. 따라서 PureComponent는 필요한 곳에 적재적소에 활용하는 것이 성능에 도움이 된다.

#### static getDerivedStateFromProps()

이 메서드는 render()를 호출하기 직전에 호출된다.

static으로 선언되어 있어 this에 접근할 수 없고 여기서 반환하는 객체는 해당 객체의 내용이 모두 state로 들어가게 된다. 이에 반해 null을 반환하면 아무런 일도 일어나지 않는다.

주의할 점은 모든 render() 실행 시에 호출된다는 점이다.

#### getSnapShotBeforeUpdate()

이는 DOM이 업데이트되기 직전에 호출된다.

여기서 반환되는 값은 componentDidUpdate로 전달된다. DOM에 렌더링되기 전에 윈도우 크기를 조절하거나 스크롤 위치를 조정하는 등의 작업을 처리하는데 유용하다.

#### getDerivedStateFromError()

생명 주기가 아닌 에러 상황에서 실행되는 메서드다.

componentDidCatch, getDerivedStateFromError, getSnapshotBeforeUpdate는 아직 리액트 훅으로 구현돼 있지 않기 때문에 이 세 가지 메서드가 필요한 경우가 있다면 반드시 클래스형 컴포넌트를 사용해야한다.

리액트 팀은 곧 이 세 가지 메서드와 동일한 작업을 할 수 있는 훅을 추가할 것이라 언급했지만 구체적으로 아직 밝힌 바 없다.

getDerivedStateFromErrors는 자식 컴포넌트에서 에러가 발생했을 때 호출되는 에러 메서드다.

getDerivedStateFromError는 반드시 state 값을 반환해야 하는데 하위 컴포넌트에서 에러가 발생했을 경우에 어떻게 자식 리액트 컴포넌트를 렌더링할지 결정하는 용도로 제고오디는 메서드이기 때문에 반드시 미리 정의해둔 state값을 반환해야 한다. 또한 렌더링 과정에서 호출되는 메서드이기 때문에 부수 효과를 발생시켜서는 안 된다.

#### componentDidCatch

componentDidCatch는 자식 컴포넌트에서 에러가 발생했을 때 실행되며, getDerivedStateFromError에서 에러를 잡고 state를 결정한 이후에 실행된다.

componentDidCatch는 두 개의 인수를 받는데 첫 번째는 getDerivedStateFromError와 동일한 error, 그리고 정확히 어떤 컴포넌트가 에러를 발생시켰는지 정보를 가지고 있는 info다.

getDerivedStateFromError()에서 하지 못한 부수 효과를 수행할 수 있으며 render 단계에서 실행되는 getDerivedStateFromError와 다르게 componentDidCatch는 커밋 단계에서 실행되기 때문이다.

즉 componentDidCatch는 리액트에서 에러 발생 시 이 메서드에서 제공되는 에러 정보를 바탕으로 로깅하는 등의 용도로 사용할 수 있다.

<hr>

### 클래스형 컴포넌트의 한계

클래스형 컴포넌트에서 제공하는 메서드만으로도 완성도 있는 리액트 애플리케이션을 만드는 데 충분해 보이지만 어떤 문제점 때문에 리액트는 함수형 컴포넌트에 훅을 돕한 새로운 패러다임을 만든 것일까

1. 데이터의 흐름을 추적하기 어렵다.

서로 다른 여러 메서드에서 state의 업데이트가 일어날 수 있으며, 코드 작성 시 메서드의 순서가 강제돼 있는 것이 아니기 때뭉네 사람이 읽기가 매우 어렵다.

클래스에 작성할 때는 메서드의 순서를 맞춰줘야 하는 것은 아니기 때문에 주의를 기울이지 않는다면 생명주기 메서드의 순서와 상관없이 코드가 작성돼 있을 수 있다.

즉, 코드를 읽는 과정에서 숙련된 개발자라도 state의 흐름을 판단하기 어렵다.

2. 애플리케이션 내부 로직의 재사용이 업렵다.

애플리 케이션의 규모가 커질수록 재사용할 로직도 많아지는데, 이를 클래스형 컴포넌트 환경에서 매끄럽게 처리하기 쉽지 않다.

extends, PureComponent와 같이 컴포넌트를 상속해서 중복 코드를 관리할 수 있지만 상속되고 있는 클래스의 흐름을 쫓아야 하기 때문에 복잡도가 증가하고 코드의 흐름을 좇기가 쉽지 않다.

3. 기능이 많아질수록 컴포넌트의 크기가 커진다.

컴포넌트 내부에 로직이 많아질수록, 또 내부에서 처리하는 데이터 흐름이 복잡해져 생명주기 메서드 사용이 잦아지는 경우 컴포넌트의 크기가 기하급수적으로 커지는 문제가 발생한다.

4. 클래스는 함수에 비해 상대적으로 어렵다.

많은 자바스크립트 개발자는 클래스보다 함수에 더 익숙하다. 그리고 함수에 비해 클래스의 사용이 비교적 어렵고 일반적이지 않다.

대부분 언어와 다르게 동작하는 this를 비롯한 자바스크립트의 작동 방식은 혼란에 빠지게 할 수 있다.

5. 코드 크기를 최적화하기 힘들다.

클래스형 컴포넌트는 쵲어 결과물인 번들 크기를 줄이는 데도 어려움을 겪는다.

6. 핫 리로딩을 하는데 불리하다.

> 핫 리로딩이란 코드에 변경 사항이 발생했을 때 앱을 다시 시작하지 않고도 해당 변경된 코드만 업데이트해 변경 사항을 빠르게 적용하는 기법을 말한다.

클래스형 컴포넌트는 최초 렌더링 시에 instance를 생성하고 그 내부에서 state 값을 관리하는데, 이 instance 내부에 있는 render를 수정하게 되면 이를 반영할 수 있는 방법은 오직 instance를 새로 만드는 것 뿐이다.

새롭게 만들어진 instance에서 값은 당연히 초기화될 수밖에 없다.

<hr>

### 함수형 컴포넌트

함수형 컴포넌트는 단순히 무상태 컴포넌트를 구현하기 위한 하나의 수단에 불과하지만 16.8에서 함수형 컴포넌트에서 사용 가능한 훅이 등장하면서 각광받고 있다.

함수형 컴포넌트는 render 내부에서 필요한 함수를 선언할 때 this 바인딩을 조심할 필요도 없으며, state는 객체가 아닌 원시값으로 관리되어 훨씬 사용하기가 편해졌다.

렌더링하는 코드인 return에서도 굳이 this를 사용하지 않더라고 props와 state에 접근할 수 있게 됐다.

<hr>

### 함수형 컴포넌트 vs 클래스형 컴포넌트

-   생명주기 메서드의 부재

클래스형 컴포넌트의 생명주기 메서드가 함수형 컴포넌트에서는 존재하지 않는다.

함수형 컴포넌트는 props를 받아 단순히 리액트 요소만 반환하는 함수인 반면, 클래스형 컴포넌트는 render 메서드가 있는 React.Component를 상속받아 구현하는 자바스크립트 클래스이기 때문이다.

즉, 생명주기 메서드는 React.Component에서 오는 것이기 때문에 클래스형 컴포넌트가 아닌 이상 생명주기 메섣르르 더는 사용할 수 없다는 뜻이다.

반면 함수형 컴포넌트는 useEffect 훅을 사용해 앞서 언급했던 생명주기 메서드인 componentDidMount, componentDidUpdate, componentWillUnmount를 비슷하게 구현할 수 있다.

**주의할 점은 비슷할 뿐이지 똑같다는 의미가 아니다. useEffect는 생명주기를 위한 훅이 아닌 state를 활용해 동기적으로 부수 효과를 만드는 메커니즘이다.**

-   함수형 컴포넌트와 렌더링 값

함수형 컴포넌트는 렌더링된 값을 고정하고, 클래스형 컴포넌트는 그렇지 못한다.

클래스 컴포넌트는 props의 값을 항상 this로 부터 가져온다. 클래스형 컴포넌트의 props는 외부에서 변경되지 않는 이상 불변 값이지만 this가 가리키는 객체, 즉 컴포넌트의 인스턴스의 멤버는 변경 가능한 값이다.

따라서 render 메서드를 비롯한 리액트의 생명주기가 메서드가 변경된 값을 읽을 수 있게 된다. 이 경우 부모 컴포넌트가 props를 변경해 컴포넌트가 다시 렌더링됐다는 것은 this.props의 값이 변경된 것이다.

함수형 컴포넌트는 렌더링이 일어날 때마다 그 순간의 값인 props와 state를 기준으로 렌더링된다. props와 state가 변경되면, 다시 한 번 그 값을 기준으로 함수가 호출된다고 볼 수 있다. 반면 클래스형 컴포넌트는 시간의 흐름에 따라 변화하는 this를 기준으로 렌더링이 일어난다.

<hr>
