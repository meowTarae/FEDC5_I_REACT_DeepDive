💡 일반 적인 DOM이 렌더링 되어지는 과정!

1. 사용자가 요청한 주소를 통해 HTML 파일을 다운로드
2. 브라우저의 렌더링 엔진은 HTML을 파싱하여 DOM 트리를 만듬
3. 파싱 과정 중 CSS 파일을 만나면 CSS파일을 다운
4. 브라우저의 렌더링 엔진은 CSS도 파싱하여 CSS노드로 이루어진 CSSOM 트리를 만듬
5. DOM트리를 순회하여 사용자의 눈에 보이는 노드만 방문함
6. 사용자의 눈에 보이지 않는 제외된 노드의 정보를 CSSOM에서 찾고 CSS정보를 노드에 적용함

**레이아웃 & 페인팅**

- 레이아웃
  Node가 브라우저 화면의 어느 좌표에 정확하게 나타나야 하는지에 대한 계산을 하는 과정
- 페인팅
  레이아웃을 거친 Node에 색과 같은 실제 모습을 그리는 과정

레이아웃을 거치면 반드시 페인팅 과정을 거치게됨

**Virtual DOM 의 탄생 배경**

일반 DOM에서 색상의 변경이 일어나는경우 리페인팅만 일어나기 때문에 비용이 적게 발생함

but 레이아웃 즉 크기를 변경할 경우에는 반드시 리페인팅을 동반하기 때문에 비용이 많이 발생함

but!!! 레이아웃이 심지어 상위 요소에서 발생하는경우 하위 요소 모두가 동일한 과정이 발생함

but!!!!!! SPA에서는 이런 현상이 매우 심함

💡 이런 문제를 개선 하기 위해 Virtual DOM 가상 돔이 탄생했고,
가상 DOM은 React가 관리하는 가상의 DOM을 의미함

🔥 **Virtual DOM의 오해**

Virtual DOM의 성능이 일반적인 브라우저 DOM보다 빠르다는 것은 오해!

그저 브라우저와 개발자에게 렌더링에서 도움을 주기 위함이 사용되어지는 이유임

그리고 실제 어플리케이션을 이용할 만큼 충분히 빠르기 때문에 선택된 기술이지 절대 DOM보다 빠르지 않음

**React Fiber**

Fiber 는 JS의 평범한 객체이며, 파이버 재 조정자 ( fiber-reconciler )가 관리함

Fiber는 가상 DOM 과 일반 DOM의 변경 사항을 수집함

⇒ 그리고 차이가 존재하면 변경 정보를 통해 Fiber를 기준으로 화면에 렌더링을 요청함

Fiber는 애플리케이션에서 발생하는 애니메이션, 레이아웃, 인터랙션을 올바른 결과물로 만드는 반응성 문제

해결이 목표이며, 이를 위해 비동기 적으로 3가지 일을 할 수 있음

- 작업을 작은 단위로 분할하고 쪼갠 다음, 우선 순위를 정함
- 이런 작업을 일시 중단하고 나중에 다시 시작할 수 있음
- 이전에 했던 작업을 다시 재사용하거나 필요없는 경우 폐기할 수 있음

**React Fiber Tree**

React 내부에 2개의 Fiber Tree가 존재함

1. 현재의 모습을 담고 있는 Fiber Tree
2. 작업중인 상태를 나타내는 workInProgress Tree

React Fiber의 작업이 완료되면, React는 단순하게 workInProgress Tree를 현재의 Tree로 변경해버림

이런 기술을 더블 버퍼링이라고함 ( 더블 버퍼링은 React의 개념이 아닌 Computer 그래픽 관련 용어 )

**변화가 일어나면?**

맨처음 Tree를 그릴때는 앞서 알아본 2개의 Fiber Tree를 모두 그려야하지만, 이후

setState와 같은 변화가 일어나면 기존의 Fiber에서 업데이트된 props를 전달받아 내부에서 처리함
